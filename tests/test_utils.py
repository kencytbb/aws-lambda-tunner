"""\nTests for utility functions.\n"""\n\nimport pytest\nimport json\nimport tempfile\nfrom pathlib import Path\n\nfrom aws_lambda_tuner.utils import (\n    validate_arn,\n    encode_payload,\n    decode_response,\n    calculate_statistics,\n    format_duration,\n    calculate_cost,\n    retry_with_backoff,\n    load_json_file,\n    save_json_file,\n    safe_divide,\n    chunk_list,\n    get_memory_sizes\n)\n\n\nclass TestValidateArn:\n    """Test ARN validation."""\n    \n    def test_valid_arn(self):\n        """Test valid ARN."""\n        arn = "arn:aws:lambda:us-east-1:123456789012:function:my-function"\n        assert validate_arn(arn) is True\n    \n    def test_invalid_arn_format(self):\n        """Test invalid ARN format."""\n        invalid_arns = [\n            "not-an-arn",\n            "arn:aws:s3:::my-bucket",  # S3 ARN\n            "arn:aws:lambda:us-east-1",  # Incomplete\n            "",\n            None\n        ]\n        for arn in invalid_arns:\n            assert validate_arn(arn) is False\n\n\nclass TestEncodePayload:\n    """Test payload encoding."""\n    \n    def test_encode_dict_payload(self):\n        """Test encoding dictionary payload."""\n        payload = {"key": "value", "number": 123}\n        encoded = encode_payload(payload)\n        assert encoded == '{"key": "value", "number": 123}'\n    \n    def test_encode_string_payload(self):\n        """Test encoding string payload."""\n        payload = '{"already": "json"}'\n        encoded = encode_payload(payload)\n        assert encoded == payload\n    \n    def test_invalid_json_string(self):\n        """Test invalid JSON string raises error."""\n        with pytest.raises(ValueError):\n            encode_payload("not valid json")\n    \n    def test_invalid_payload_type(self):\n        """Test invalid payload type raises error."""\n        with pytest.raises(TypeError):\n            encode_payload(123)\n\n\nclass TestDecodeResponse:\n    """Test response decoding."""\n    \n    def test_decode_valid_response(self):\n        """Test decoding valid response."""\n        from io import BytesIO\n        response = BytesIO(b'{"result": "success"}')\n        decoded = decode_response(response)\n        assert decoded == {"result": "success"}\n    \n    def test_decode_invalid_response(self):\n        """Test decoding invalid response."""\n        from io import BytesIO\n        response = BytesIO(b'not json')\n        decoded = decode_response(response)\n        assert "error" in decoded\n\n\nclass TestCalculateStatistics:\n    """Test statistics calculation."""\n    \n    def test_calculate_statistics_normal(self):\n        """Test statistics with normal data."""\n        values = [10, 20, 30, 40, 50]\n        stats = calculate_statistics(values)\n        \n        assert stats["min"] == 10\n        assert stats["max"] == 50\n        assert stats["mean"] == 30\n        assert stats["median"] == 30\n        assert stats["stddev"] > 0\n        assert stats["p95"] <= 50\n        assert stats["p99"] <= 50\n    \n    def test_calculate_statistics_empty(self):\n        """Test statistics with empty data."""\n        stats = calculate_statistics([])\n        \n        assert all(v == 0 for v in stats.values())\n    \n    def test_calculate_statistics_single_value(self):\n        """Test statistics with single value."""\n        stats = calculate_statistics([42])\n        \n        assert stats["min"] == 42\n        assert stats["max"] == 42\n        assert stats["mean"] == 42\n        assert stats["median"] == 42\n        assert stats["stddev"] == 0\n\n\nclass TestFormatDuration:\n    """Test duration formatting."""\n    \n    def test_format_milliseconds(self):\n        """Test formatting milliseconds."""\n        assert format_duration(150.5) == "150.50ms"\n        assert format_duration(999) == "999.00ms"\n    \n    def test_format_seconds(self):\n        """Test formatting seconds."""\n        assert format_duration(1500) == "1.50s"\n        assert format_duration(45678) == "45.68s"\n    \n    def test_format_minutes(self):\n        """Test formatting minutes."""\n        assert format_duration(65000) == "1m 5.00s"\n        assert format_duration(180000) == "3m 0.00s"\n\n\nclass TestCalculateCost:\n    """Test cost calculation."""\n    \n    def test_calculate_cost_basic(self):\n        """Test basic cost calculation."""\n        # 512MB for 100ms\n        cost = calculate_cost(512, 100, 1)\n        assert cost > 0\n        assert cost < 0.001  # Should be very small\n    \n    def test_calculate_cost_multiple_requests(self):\n        """Test cost with multiple requests."""\n        cost_single = calculate_cost(1024, 1000, 1)\n        cost_multiple = calculate_cost(1024, 1000, 1000)\n        \n        assert cost_multiple > cost_single\n    \n    def test_calculate_cost_zero_duration(self):\n        """Test cost with zero duration."""\n        cost = calculate_cost(256, 0, 1)\n        assert cost >= 0.0000002  # Minimum request cost\n\n\nclass TestRetryWithBackoff:\n    """Test retry decorator."""\n    \n    def test_successful_function(self):\n        """Test function that succeeds immediately."""\n        call_count = 0\n        \n        @retry_with_backoff(retries=3, backoff_in_seconds=0.1)\n        def success_func():\n            nonlocal call_count\n            call_count += 1\n            return "success"\n        \n        result = success_func()\n        assert result == "success"\n        assert call_count == 1\n    \n    def test_retry_then_success(self):\n        """Test function that fails then succeeds."""\n        call_count = 0\n        \n        @retry_with_backoff(retries=3, backoff_in_seconds=0.1)\n        def eventual_success():\n            nonlocal call_count\n            call_count += 1\n            if call_count < 3:\n                raise Exception("Temporary failure")\n            return "success"\n        \n        result = eventual_success()\n        assert result == "success"\n        assert call_count == 3\n    \n    def test_max_retries_exceeded(self):\n        """Test function that always fails."""\n        call_count = 0\n        \n        @retry_with_backoff(retries=3, backoff_in_seconds=0.1)\n        def always_fails():\n            nonlocal call_count\n            call_count += 1\n            raise Exception("Always fails")\n        \n        with pytest.raises(Exception, match="Always fails"):\n            always_fails()\n        \n        assert call_count == 3\n\n\nclass TestFileOperations:\n    """Test file operations."""\n    \n    def test_load_save_json_file(self, temp_dir):\n        """Test loading and saving JSON files."""\n        test_data = {"key": "value", "number": 42}\n        filepath = temp_dir / "test.json"\n        \n        # Save\n        save_json_file(test_data, str(filepath))\n        assert filepath.exists()\n        \n        # Load\n        loaded = load_json_file(str(filepath))\n        assert loaded == test_data\n    \n    def test_load_nonexistent_file(self):\n        """Test loading non-existent file."""\n        with pytest.raises(FileNotFoundError):\n            load_json_file("/nonexistent/file.json")\n    \n    def test_load_invalid_json(self, temp_dir):\n        """Test loading invalid JSON."""\n        filepath = temp_dir / "invalid.json"\n        filepath.write_text("not valid json")\n        \n        with pytest.raises(ValueError):\n            load_json_file(str(filepath))\n\n\nclass TestSafeDivide:\n    """Test safe division."""\n    \n    def test_normal_division(self):\n        """Test normal division."""\n        assert safe_divide(10, 2) == 5\n        assert safe_divide(7.5, 2.5) == 3\n    \n    def test_division_by_zero(self):\n        """Test division by zero."""\n        assert safe_divide(10, 0) == 0\n        assert safe_divide(10, 0, default=999) == 999\n\n\nclass TestChunkList:\n    """Test list chunking."""\n    \n    def test_chunk_list_even(self):\n        """Test chunking with even division."""\n        items = list(range(10))\n        chunks = chunk_list(items, 5)\n        \n        assert len(chunks) == 2\n        assert chunks[0] == [0, 1, 2, 3, 4]\n        assert chunks[1] == [5, 6, 7, 8, 9]\n    \n    def test_chunk_list_uneven(self):\n        """Test chunking with uneven division."""\n        items = list(range(10))\n        chunks = chunk_list(items, 3)\n        \n        assert len(chunks) == 4\n        assert len(chunks[-1]) == 1\n    \n    def test_chunk_list_larger_than_list(self):\n        """Test chunk size larger than list."""\n        items = list(range(5))\n        chunks = chunk_list(items, 10)\n        \n        assert len(chunks) == 1\n        assert chunks[0] == items\n\n\nclass TestGetMemorySizes:\n    """Test memory size recommendations."""\n    \n    def test_speed_strategy(self):\n        """Test memory sizes for speed strategy."""\n        sizes = get_memory_sizes('speed')\n        assert all(size >= 512 for size in sizes)\n        assert max(sizes) >= 2048\n    \n    def test_cost_strategy(self):\n        """Test memory sizes for cost strategy."""\n        sizes = get_memory_sizes('cost')\n        assert min(sizes) == 128\n        assert max(sizes) <= 1024\n    \n    def test_balanced_strategy(self):\n        """Test memory sizes for balanced strategy."""\n        sizes = get_memory_sizes('balanced')\n        assert 256 in sizes\n        assert 2048 in sizes\n    \n    def test_comprehensive_strategy(self):\n        """Test memory sizes for comprehensive strategy."""\n        sizes = get_memory_sizes('comprehensive')\n        assert len(sizes) > 6\n        assert min(sizes) == 128\n        assert max(sizes) >= 3008\n    \n    def test_unknown_strategy(self):\n        """Test unknown strategy returns balanced."""\n        sizes = get_memory_sizes('unknown')\n        assert sizes == get_memory_sizes('balanced')\n